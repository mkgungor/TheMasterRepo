package us.lazerzes.citysim.util;

import java.util.ArrayList;
import java.util.Random;

import us.lazerzes.citysim.city.City;
import us.lazerzes.citysim.driver.Driver;
import us.lazerzes.citysim.location.*;
import us.lazerzes.csim.util.Direction;

public class IterationHelper {
	
	public static boolean iteration(ArrayList<Driver> drivers, City city, Random rand){
		
		for(Driver d : drivers){

			GenericLocation current = d.getCurrentLocation(), via, end;
			ArrayList<GenericLocation> possible = DirectionHelper.getSurrounding(current, city);
			
			if(!possible.equals(null)){
				
				ArrayList<GenericLocation> toRemove = new ArrayList<GenericLocation>();
				
				for(GenericLocation l : possible){
					
					if(!(l instanceof LocationStreet)){
						toRemove.add(l);
					}else{
						if(!DirectionHelper.isLegalMove(current, l)){
							toRemove.add(l);
						}
					}
					
				}
				
				possible.removeAll(toRemove);
				
				if(!possible.isEmpty()){
					
					int gen = rand.nextInt(possible.size());
					via = possible.get(gen);
					Direction dirMoved = DirectionHelper.directionMoved(current, via);
					
					end = city.getLocationAt(via.getPosition().x + dirMoved.getGridMovement().x, via.getPosition().y + dirMoved.getGridMovement().y);
					
					if(end.equals(null)){
						System.out.println(String.format("Driver %d has driven off the world! The map may not have been initialized properly -- Ending Program", d.getDriverID()));
						return false;
					}
					
					d.setCurrentLocation(end);
					DisplayHelper.printMove(d, current, via);
				
				}else{
					System.out.println(String.format("Unable to find a legal move for Driver %d -- Ending Program", d.getDriverID()));
					return false;
				}
			}else{
				System.out.println(String.format("Unable to find any surrounding spaces for %s -- Ending Program", current.getName()));
				return false;
			}
		}
		
		return true;
		
	}

	public static boolean checks(ArrayList<Driver> drivers){
		
		boolean endCaseMet = true;
		int i = 0;
		
		while(endCaseMet && i < drivers.size()){
			endCaseMet = drivers.get(i).checkCurrentPosition();
			i++;
		}
		
		while(i < drivers.size()){
			drivers.get(i).checkCurrentPosition();
			i++;
		}
		
		return endCaseMet;
		
	}
	
}
